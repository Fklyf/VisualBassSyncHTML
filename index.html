<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>VisualBassSync HTML</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background-color: black;
      color: white;
      font-family: sans-serif;
      overflow: hidden;
    }
    /* The brightness display is always centered */
    #brightnessDisplay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: var(--brightness-font-size);
      text-align: center;
    }
    /* Connect button at the bottom center */
    #connectBtn {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 20px;
      padding: 10px 20px;
      cursor: pointer;
    }
    /* FPS counter in the top right corner */
    #fpsCounter {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: var(--fps-font-size);
      background-color: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div id="brightnessDisplay">Brightness: 0%</div>
  <button id="connectBtn">Connect Microphone</button>
  <div id="fpsCounter">FPS: 0</div>
  
  <script>
    // ----- CONSTANTS -----
    const BRIGHTNESS_FONT_SIZE = 56; // Brightness text font size in pixels
    const FPS_FONT_SIZE = 16;        // FPS counter font size in pixels
    const HUE_CYCLE_RATE = 0.004;      // Hue cycle rate (normalized units per second)
    const TARGET_FREQS = [35, 40, 45, 50, 55];  // Bass frequencies (Hz)
    const BRIGHTNESS_GAIN = 1.6;       // Boost factor for brightness calculation
    const CONTROL_SENSITIVITY = 1.0;   // Sensitivity multiplier
    const SMOOTHING_FACTOR = 0.9;      // Smoothing factor for brightness transitions
    const FFT_SIZE = 2048;           // FFT size for audio analysis
    
    // Set CSS variables for font sizes.
    document.documentElement.style.setProperty('--brightness-font-size', BRIGHTNESS_FONT_SIZE + 'px');
    document.documentElement.style.setProperty('--fps-font-size', FPS_FONT_SIZE + 'px');
    
    let audioContext, analyser, frequencyData;
    let smoothedBrightness = 0;  // Running brightness value (0 to 1)
    let hue = 0;                 // Normalized hue (0 to 1) for the text color
    
    let lastFrameTime = performance.now();
    let lastFpsUpdateTime = performance.now();
    let frameCount = 0;
    
    let animationFrameId;
    
    // Initialize audio processing when the user clicks the Connect Microphone button.
    async function initAudio() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        document.getElementById('connectBtn').style.display = 'none';
        
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = FFT_SIZE;
        analyser.smoothingTimeConstant = 0.8;
        
        const source = audioContext.createMediaStreamSource(stream);
        source.connect(analyser);
        
        frequencyData = new Uint8Array(analyser.frequencyBinCount);
        
        // Start the update loop.
        update();
      } catch (err) {
        console.error('Error accessing microphone:', err);
        document.getElementById('connectBtn').textContent = 'Error connecting microphone';
      }
    }
    
    // The update loop: handles audio processing, hue cycling, and FPS counting.
    function update() {
      const now = performance.now();
      const deltaTime = (now - lastFrameTime) / 1000; // in seconds
      lastFrameTime = now;
      
      // Update hue using the defined cycle rate.
      hue = (hue + HUE_CYCLE_RATE * deltaTime) % 1;
      
      if (analyser) {
        analyser.getByteFrequencyData(frequencyData);
        const sampleRate = audioContext.sampleRate;
        const resolution = sampleRate / analyser.fftSize; // Hz per FFT bin
      
        let sum = 0;
        TARGET_FREQS.forEach(freq => {
          let index = Math.round(freq / resolution);
          index = Math.min(index, frequencyData.length - 1);
          sum += frequencyData[index];
        });
        const avgAmplitude = sum / TARGET_FREQS.length;
        let brightness = (avgAmplitude * BRIGHTNESS_GAIN / 255) * CONTROL_SENSITIVITY;
        brightness = Math.min(brightness, 1.0);
      
        // Smooth the brightness transitions.
        smoothedBrightness = (smoothedBrightness * SMOOTHING_FACTOR) + (brightness * (1 - SMOOTHING_FACTOR));
      
        // Convert brightness to a percentage.
        const brightnessPercent = Math.floor(smoothedBrightness * 100);
      
        // Update the brightness display text and set its color based on the cycling hue.
        const brightnessDisplay = document.getElementById('brightnessDisplay');
        brightnessDisplay.textContent = `Brightness: ${brightnessPercent}%`;
        brightnessDisplay.style.color = `hsl(${hue * 360}, 100%, 50%)`;
      }
      
      // FPS counter: update every second.
      frameCount++;
      if (now - lastFpsUpdateTime >= 1000) {
        const fps = frameCount;
        document.getElementById('fpsCounter').textContent = `FPS: ${fps}`;
        frameCount = 0;
        lastFpsUpdateTime = now;
      }
      
      // Continue the update loop with requestAnimationFrame.
      animationFrameId = requestAnimationFrame(update);
    }
    
    // Set up the Connect Microphone button.
    document.getElementById('connectBtn').addEventListener('click', initAudio);
  </script>
</body>
</html>
